<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>네모네모만들기</title>
  </head>
  <body>
    <div id="container"></div>
  </body>

  <script
    async
    src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
  ></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/",
        "three/": "https://cdn.skypack.dev/three@0.142.0/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";

    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";

    THREE.ColorManagement.enabled = true;

    let container, camera, scene, renderer, mesh;

    const api = {
      counts: 1,
    };

    init(); //초기화
    initGUI(); // GUI 초기화
    initMesh();
    function init() {
      container = document.getElementById("container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x8fbcd4);

      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        20
      );
      camera.position.z = 10;
      scene.add(camera);

      scene.add(new THREE.AmbientLight(0x8fbcd4, 2));

      const pointLight = new THREE.PointLight(0xffffff, 200);
      camera.add(pointLight);

      const geometry = initMesh(); // 초기화..?
      const material = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        flatShading: true,
      });

      mesh = new THREE.Mesh(geometry, material);

      scene.add(mesh);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.useLegacyLights = false;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.setAnimationLoop(function () {
        renderer.render(scene, camera);
      });
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableZoom = false;

      window.addEventListener("resize", onWindowResize);
    }

    //
    function initMesh() {
      /** 정육면체 만들기 **/
      const geometry = new THREE.BoxGeometry(2, 2, 2, 32, 32, 32);
      geometry.morphAttributes.position = [];
      const positionAttribute = geometry.attributes.position;
      const spherePositions = [];
      const twistPositions = [];
      const direction = new THREE.Vector3(1, 0, 0);
      const vertex = new THREE.Vector3();
      for (let i = 0; i < positionAttribute.count; i++) {
        const x = positionAttribute.getX(i);
        const y = positionAttribute.getY(i);
        const z = positionAttribute.getZ(i);

        spherePositions.push(
          x * Math.sqrt(1 - (y * y) / 2 - (z * z) / 2 + (y * y * z * z) / 3),
          y * Math.sqrt(1 - (z * z) / 2 - (x * x) / 2 + (z * z * x * x) / 3),
          z * Math.sqrt(1 - (x * x) / 2 - (y * y) / 2 + (x * x * y * y) / 3)
        );
        vertex.set(x * 2, y, z); // stretch along the x-axis so we can see the twist better
        vertex
          .applyAxisAngle(direction, (Math.PI * x) / 2)
          .toArray(twistPositions, twistPositions.length);
      }

      // add the spherical positions as the first morph target
      geometry.morphAttributes.position[0] = new THREE.Float32BufferAttribute(
        spherePositions,
        3
      );

      // add the twisted positions as the second morph target
      geometry.morphAttributes.position[1] = new THREE.Float32BufferAttribute(
        twistPositions,
        3
      );
      makeMerged(geometry);

      return geometry;
    }
    //init Mesh() END ________________________________________________________________
    function makeMerged(geometry) {
      const geometries = [];
      const matrix = new THREE.Matrix4();

      for (let i = 0; i < api.count; i++) {
        randomizeMatrix(matrix);

        const instanceGeometry = geometry.clone();
        instanceGeometry.applyMatrix4(matrix);

        geometries.push(instanceGeometry);
      }
      console.log(geometries);
      const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);

      scene.add(new THREE.Mesh(mergedGeometry, material));
    }

    // 컨트롤 GUI 초기화 ______________________________________________________________
    function initGUI() {
      const params = {
        Spherify: 0,
        Twist: 0,
        Size: 0.5,
      };
      const colors = {
        R: 1,
        G: 0,
        B: 0,
      };
      const positions = {
        X: 0,
        Y: 0,
        Z: 0,
      };
      /**
       * GUI 폴더에 분류하기
       * 1. 하나의 폴더 만들 때는 생성자 안에 타이틀 넣기
       *  - gui = new GUI({ title : 'Morph Targets'})
       * 2. 여러 폴더 만들 때는 변수 지정
       * - const morph = gui.addFolder("Morph Targets");
       * - morph.open()/ morph.close()
       **/

      const gui = new GUI({});
      const morph = gui.addFolder("Morph Targets");
      const size = gui.addFolder("위치");
      const color = gui.addFolder("색상");
      const count = gui.addFolder("Count");
      morph.open();
      size.open();

      morph
        .add(params, "Spherify", 0, 1)
        .step(0.01)
        .onChange(function (value) {
          mesh.morphTargetInfluences[0] = value;
        });
      morph
        .add(params, "Twist", 0, 1)
        .step(0.01)
        .onChange(function (value) {
          mesh.morphTargetInfluences[1] = value;
        });

      //  POSITION XYB : __________________________________________________________________
      size
        .add(positions, "X", -5, 5)
        .step(0.01)
        .onChange(function (value) {
          console.log(mesh);
          mesh.position.x = value;
        });
      size
        .add(positions, "Y", -5, 5)
        .step(0.01)
        .onChange(function (value) {
          console.log(mesh);
          mesh.position.y = value;
        });
      size
        .add(positions, "Z", -5, 5)
        .step(0.01)
        .onChange(function (value) {
          console.log(mesh);
          mesh.position.z = value;
        });
      // Color RGB : __________________________________________________________________
      color
        .add(colors, "R", 0, 1)
        .step(0.01)
        .onChange(function (value) {
          mesh.material.color.r = value;
        });
      color
        .add(colors, "B", 0, 1)
        .step(0.01)
        .onChange(function (value) {
          mesh.material.color.b = value;
        });
      color
        .add(colors, "G", 0, 1)
        .step(0.01)
        .onChange(function (value) {
          mesh.material.color.g = value;
        });
      count.add(counts, "count", 1, 100).step(1).onChange(initMesh);
      // 개체 수 : __________________________________________________________________
    }

    //
    function makeInstatnced(geometry) {
      const matrix = new THREE.Matrix4();
      const mesh = new THREE.InstancedMesh(geometry, material, api.count);

      const api = {
        count: 1,
      };
      for (let i = 0; i < api.count; i++) {
        randomizeMatrix(matrix);
        mesh.setMatrixAt(i, matrix);
      }

      scene.add(mesh);

      //

      const geometryByteLength = getGeometryByteLength(geometry);

      guiStatsEl.innerHTML = [
        "<i>GPU draw calls</i>: 1",
        "<i>GPU memory</i>: " +
          formatBytes(api.count * 16 + geometryByteLength, 2),
      ].join("<br/>");
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</html>
